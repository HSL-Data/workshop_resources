<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Wrangling in R</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer_2.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, inverse, title-slide

.title[
# Data Wrangling in R
]

---







Data analysis involves a large amount of [janitorwork](http://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html) -- munging and cleaning data to facilitate downstream data analysis. In fact, data scientists say that around [80%](https://www.infoworld.com/article/3228245/data-science/the-80-20-data-science-dilemma.html) of their time is taken up by data cleaning tasks compared to just 20% for the actual analyses.

Our goal will be to produce "tidy data" that we can then use to derive some insights. [Tidy data](https://vita.had.co.nz/papers/tidy-data.pdf) is defined as:
1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.

To transform the data into tidy data will take different steps depending on the nature of the untidyness. Hadley Wickham, who works for RStudio, says "tidy datasets are all alike but every messy dataset is messy in its own way."

This lesson demonstrates techniques for data cleaning and manipulation using the split-apply-combine strategy. We will make use of the tidyr package to clean the data. The dplyr package will help us effectively manipulate and conditionally compute summary statistics over subsets of data, while the stringr package will help us interact with string data. 

**This lesson assumes a [basic familiarity with R](r-basics.html) and [data frames](r-dataframes.html).**

**Recommended Resources** 
1. The [**_R for Data Science_ book**](http://r4ds.had.co.nz/tibbles.html) is a fabulous resource for learning to do data science in R.

2. There are cheatsheets available on the [RStudio website](https://www.rstudio.com/resources/cheatsheets/) for **tidyr**, **dplyr**, and **stringr**, among others. They are excellent quick reference guides for what we will learn today.
---
### Set up data

We need to load the readr, dplyr, tidyr, and stringr packages. All of these packages are contained in the tidyverse megapackage. Let's load those packages now - hopefully you have already installed them. 


```r
#install.packages("tidyverse")
# Load packages
library(tidyverse)
library(lubridate)
```
---
The purpose of our class today is to figure out the relationship between bigfoot sightings and the production of beer over time. The problem is that we do not have a single dataset with all of the variables that we will need. To get this dataset, we need to combine multiple disparate datasets.


```r
# Read in original datasets
# bigfoot : A data set looking at bigfoot sightings
# across time, season, and state
bigfoot &lt;-  readr::read_csv('bigfoot.csv') %&gt;%
 mutate(year = lubridate::year(date))

# bigfoot_counts : A dataset with count of 
# bigfoot sightings across time, county and state
bigfoot_counts &lt;- readr::read_csv("bigfoot_season_count.csv")

# beer_states: A dataset looking at beer production across
# states and time
beer_states &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv') %&gt;% 
  filter(state != "total")
```
---

```r
View(bigfoot)
# Display the data
glimpse(bigfoot)
```

```
## Rows: 5,021
## Columns: 12
## $ title       &lt;chr&gt; NA, NA, "Report 6496: Bicycling student has night encounte…
## $ state       &lt;chr&gt; "Alabama", "Alaska", "Rhode Island", "Pennsylvania", "Oreg…
## $ date        &lt;date&gt; NA, NA, 1974-09-20, NA, NA, 1973-09-28, 1971-08-01, 2010-…
## $ season      &lt;chr&gt; "Summer", "Fall", "Fall", "Summer", "Spring", "Fall", "Sum…
## $ precip_type &lt;chr&gt; NA, NA, NA, NA, NA, "rain", NA, NA, NA, NA, "rain", NA, "r…
## $ number      &lt;dbl&gt; 30680, 1261, 6496, 8000, 703, 9765, 4983, 31940, 5692, 438…
## $ temperature &lt;dbl&gt; NA, NA, 73.425, NA, NA, 61.425, NA, 80.810, NA, NA, 64.245…
## $ dew_point   &lt;dbl&gt; NA, NA, 65.72, NA, NA, 51.03, NA, 67.34, 32.55, NA, 54.64,…
## $ humidity    &lt;dbl&gt; NA, NA, 0.86, NA, NA, 0.79, NA, 0.68, 0.45, NA, 0.79, 0.61…
## $ visibility  &lt;dbl&gt; NA, NA, 2.750, NA, NA, 10.000, NA, 6.922, 8.880, NA, 9.700…
## $ uv_index    &lt;dbl&gt; NA, NA, 4, NA, NA, 7, NA, 8, 8, NA, 6, 10, 6, 7, NA, 1, 9,…
## $ year        &lt;dbl&gt; NA, NA, 1974, NA, NA, 1973, 1971, 2010, 1970, NA, 2016, 20…
```

```r
glimpse(bigfoot_counts)
```

```
## Rows: 3,565
## Columns: 7
## $ county_state &lt;chr&gt; "Adams County;Idaho", "Adams County;Idaho", "Adams County…
## $ year         &lt;dbl&gt; 1990, 2009, 1972, 1985, 2012, 2003, 2006, 2011, 2011, 201…
## $ Fall         &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …
## $ Spring       &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…
## $ Summer       &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, NA, NA, NA, NA, …
## $ Unknown      &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…
## $ Winter       &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…
```

```r
glimpse(beer_states)
```

```
## Rows: 1,836
## Columns: 4
## $ state   &lt;chr&gt; "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "AK", "A…
## $ year    &lt;dbl&gt; 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 20…
## $ barrels &lt;dbl&gt; 2067.69, 2263.65, 1929.15, 2251.02, 2312.43, 2155.60, 2114.97,…
## $ type    &lt;chr&gt; "On Premises", "On Premises", "On Premises", "On Premises", "O…
```
---
## Separate &amp; Unite


```r
bigfoot_counts
```

In looking at the output of the `bigfoot_counts` dataset, we have some work to do to tidy the data for analysis. 

One of the first problems I see is that there are multiple pieces of data encoded into the column called `county_state`. Luckily, the data are separated neatly by `;`. Let's use the separate function from the tidyr package to create new columns from the original `county_state` column.

# Separate

The `separate` function is used to create multiple columns from a single column. For the `separate` function you simply need the dataset, the column you want to separate into multiple columns, the name of the new columns, and the means by which the column is separated. 


```r
#?separate
#county_state  in the bigfoot_counts dataset has 2 pieces of information 
#(county;state)

bigfoot_counts %&gt;% 
  separate(col = county_state, into = c("county", "state"), sep = ";")
```

Notice that our original variable `county_state` no longer appears. This change is good, but so far is only in the console. The original dataframe is still unchanged. 


```r
bigfoot_counts
```
---
Let's keep the change created by the `separate()` function by saving original with separate back into original


```r
bigfoot_c &lt;- bigfoot_counts %&gt;% 
  separate(col = county_state, into = c("county", "state"), sep = ";")

#Make sure to look at the variable types after a separate, they can often
#show everything as character/string/factor, when you would expect it to 
#be numeric
bigfoot_c
```
---
If the separator was not as neat as this, you can input any [regular expression](https://en.wikipedia.org/wiki/Regular_expression) into the separator argument. 

## Resources for Regular Expressions

For a nice cheatsheet for writing regular expressions in R, see a [Regex cheatsheet](http://www.cbs.dtu.dk/courses/27610/regular-expressions-cheat-sheet-v2.pdf). Jenny Bryan has created a nice website tutorial for learning to use [Regular Expressions in R](http://stat545.com/block022_regular-expression.html).


```r
new_df &lt;- tibble(a = c("Education#SEP#52", "Business#SEP#43"))
new_df
```

```
## # A tibble: 2 × 1
##   a               
##   &lt;chr&gt;           
## 1 Education#SEP#52
## 2 Business#SEP#43
```

```r
separate(data = new_df, col = a, into = c("Field", "Age"), sep = "#SEP#")
```

```
## # A tibble: 2 × 2
##   Field     Age  
##   &lt;chr&gt;     &lt;chr&gt;
## 1 Education 52   
## 2 Business  43
```

```r
new_df &lt;- tibble(a = c("Education#SEP#52", "Business#IFJ#43"))
new_df
```

```
## # A tibble: 2 × 1
##   a               
##   &lt;chr&gt;           
## 1 Education#SEP#52
## 2 Business#IFJ#43
```

```r
separate(data = new_df, col = a, into = c("Field", "Age"), sep = "#[A-Z]{3}#")
```

```
## # A tibble: 2 × 2
##   Field     Age  
##   &lt;chr&gt;     &lt;chr&gt;
## 1 Education 52   
## 2 Business  43
```
---
# Unite

Unite is essentially the opposite of separate. It acts much like paste would work, where it combines two (or more) separate columns into one while separating with a specific value


```r
# Let's pretend we want to unite the two county and state
# together from bigfoot_c
bigfoot_c %&gt;% unite(col = county_state, c("county", "state"), sep = ", ") %&gt;% select(county_state)
```

```
## # A tibble: 3,565 × 1
##    county_state                    
##    &lt;chr&gt;                           
##  1 Adams County, Idaho             
##  2 Adams County, Idaho             
##  3 Adams County, Illinois          
##  4 Alachua County, Florida         
##  5 Alachua County, Florida         
##  6 Alcona County, Michigan         
##  7 Alcona County, Michigan         
##  8 Alcona County, Michigan         
##  9 Alexander County, Illinois      
## 10 Alexander County, North Carolina
## # … with 3,555 more rows
```
---

### Exercise ###

1. Use Separate to separate the a column in `new_df` into two separate columns.

2. Reunite the two columns and use a separator of your choice.


```r
new_df &lt;- tibble(a = c("OnePiece--21", "TwoPiece--25"))
new_df
```

```
## # A tibble: 2 × 1
##   a           
##   &lt;chr&gt;       
## 1 OnePiece--21
## 2 TwoPiece--25
```

```r
#1. 
n &lt;- new_df %&gt;% separate(col = a, into = c("var", "value"), sep = "--")
n
```

```
## # A tibble: 2 × 2
##   var      value
##   &lt;chr&gt;    &lt;chr&gt;
## 1 OnePiece 21   
## 2 TwoPiece 25
```

```r
#2. 
unite(n, new_var, c("var", "value"), sep = "WHATEVER")
```

```
## # A tibble: 2 × 1
##   new_var           
##   &lt;chr&gt;             
## 1 OnePieceWHATEVER21
## 2 TwoPieceWHATEVER25
```
---
# Reshaping - pivot_wider &amp; pivot_longer

The next problem we will tackle is reshaping the dataframe. Notice that we have several rows that seem to be encoding beer production information across different years and type for the same state when we look at the `beer_states` dataset. At times, we want the dataset to be set up like this, but to be able to combine it to our other datasets, we will need to reshape.


```r
beer_states %&gt;% 
  arrange(state, year)
```

The `type` column is repeated across the states for each year. This longitudinal/panel style of dataset is considered a `long` dataset, where you have many observations and few columns/variables. This set up is nice for looking at time series or repeated measures. However, we want to turn it into a `wide` dataset, where there are more variables and fewer observations. 
---
We will use the `pivot_wider` function to change our dataset from `long` to `wide`. Conversely the `pivot_longer` function changes a dataset from `wide` to `long`.

After the dataframe, `pivot_wider()` needs 2 other arguments. The first one is where you are getting your new variable names from. Since you will be creating several variables, R needs a way to tell how to name them. The second argument, below tells us where to get the values for the new variables. 


```r
#?pivot_wider
names(beer_states)
beer_states  %&gt;% 
  pivot_wider(names_from = type, values_from = barrels)

beer_wide &lt;- beer_states  %&gt;% 
  pivot_wider(names_from = type, values_from = barrels)
```


```r
## Using names_prefix is helpful when dealing with troublesome names

bigfoot %&gt;% 
  filter(year &gt;= 2018) %&gt;% 
  group_by(state, year) %&gt;% 
  summarize(n = n()) %&gt;% 
  pivot_wider(names_from = year, values_from = n, names_prefix = "sightings_")
```

```
## # A tibble: 37 × 5
## # Groups:   state [37]
##    state       sightings_2020 sightings_2021 sightings_2018 sightings_2019
##    &lt;chr&gt;                &lt;int&gt;          &lt;int&gt;          &lt;int&gt;          &lt;int&gt;
##  1 Alabama                  2              1             NA             NA
##  2 Arizona                 NA              1             NA             NA
##  3 Arkansas                NA             NA              2             NA
##  4 California               2              2              2              3
##  5 Colorado                 1              1              1              2
##  6 Connecticut             NA             NA              2              2
##  7 Florida                  1              3              2              1
##  8 Georgia                 NA             NA              1              1
##  9 Idaho                    4              3              1              1
## 10 Illinois                 2              3             NA             NA
## # … with 27 more rows
```
---
As mentioned earlier, `pivot_longer()` is the inverse of `pivot_wider`. With `pivot_longer()` you tell R the columns that you want to gather and then the name for the new column you are creating. Notice here the `:` operator which basically means "through". The `bigfoot_c` dataset is an example of a wide dataset. So here we are grabbing all variables from `Fall` through `Winter`.


```r
#?pivot_longer
bigfoot_c_long &lt;- bigfoot_c %&gt;% 
  pivot_longer(cols = Fall:Winter) 
bigfoot_c_long &lt;- bigfoot_c_long %&gt;% 
  rename(season = name, sightings = value)
bigfoot_c_long
```

```
## # A tibble: 17,825 × 5
##    county       state  year season  sightings
##    &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;
##  1 Adams County Idaho  1990 Fall            1
##  2 Adams County Idaho  1990 Spring         NA
##  3 Adams County Idaho  1990 Summer         NA
##  4 Adams County Idaho  1990 Unknown        NA
##  5 Adams County Idaho  1990 Winter         NA
##  6 Adams County Idaho  2009 Fall            1
##  7 Adams County Idaho  2009 Spring         NA
##  8 Adams County Idaho  2009 Summer         NA
##  9 Adams County Idaho  2009 Unknown        NA
## 10 Adams County Idaho  2009 Winter         NA
## # … with 17,815 more rows
```

```r
bigfoot_c_final &lt;- bigfoot_c_long %&gt;% 
  group_by(state, year, season) %&gt;% 
  summarize(sightings = sum(sightings, na.rm = TRUE))
```
---
### Exercise ###

Using `new_df` below, create a new dataset that only has one observation per patient and contains both Systolic and Diastolic readings.


```r
# Run these lines to create new_df
a &lt;- c(1, 1, 2, 2)
b &lt;- c("Sys", "Dia", "Sys", "Dia")
c &lt;- c(125, 75, 134, 85)

new_df &lt;- tibble(patient = a, BP = b,reading = c)
new_df
```

```
## # A tibble: 4 × 3
##   patient BP    reading
##     &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;
## 1       1 Sys       125
## 2       1 Dia        75
## 3       2 Sys       134
## 4       2 Dia        85
```

```r
new_df %&gt;% pivot_wider(names_from = BP, names_glue = "BP_{BP}", values_from = reading)
```

```
## # A tibble: 2 × 3
##   patient BP_Sys BP_Dia
##     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1       1    125     75
## 2       2    134     85
```

```r
new_df %&gt;% pivot_wider(names_from = BP, names_prefix = "BP_", values_from = reading)
```

```
## # A tibble: 2 × 3
##   patient BP_Sys BP_Dia
##     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1       1    125     75
## 2       2    134     85
```
---
### Merge Datasets Together

I want to do a bit of prework to create dummy datasets that can be used to test out our join/merge functions. 


```r
x &lt;- bigfoot %&gt;%
  filter(year == 2010) %&gt;% 
  select(state, year, season) %&gt;% 
  arrange(state) %&gt;% 
  head(10) %&gt;% 
  arrange(state) %&gt;% 
  mutate(data = "x")

y &lt;- bigfoot_c_final %&gt;% 
  filter(year == 2010 ) %&gt;% 
  select(state, year, season) %&gt;% 
  head(10) %&gt;% 
  mutate(data = "y")
```
---

```r
x
```

```
## # A tibble: 10 × 4
##    state       year season  data 
##    &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
##  1 Alabama     2010 Spring  x    
##  2 Arizona     2010 Spring  x    
##  3 Arkansas    2010 Fall    x    
##  4 Arkansas    2010 Fall    x    
##  5 Arkansas    2010 Spring  x    
##  6 Arkansas    2010 Fall    x    
##  7 California  2010 Spring  x    
##  8 California  2010 Summer  x    
##  9 California  2010 Winter  x    
## 10 California  2010 Unknown x
```

```r
y
```

```
## # A tibble: 10 × 4
## # Groups:   state, year [2]
##    state    year season  data 
##    &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;
##  1 Alabama  2010 Fall    y    
##  2 Alabama  2010 Spring  y    
##  3 Alabama  2010 Summer  y    
##  4 Alabama  2010 Unknown y    
##  5 Alabama  2010 Winter  y    
##  6 Arizona  2010 Fall    y    
##  7 Arizona  2010 Spring  y    
##  8 Arizona  2010 Summer  y    
##  9 Arizona  2010 Unknown y    
## 10 Arizona  2010 Winter  y
```
---
There are several types of joins (merges) that we can use. The one you use depends upon your specific needs.

inner_join(): return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.


```r
inner_join(x, y, by = c("state", "year", "season"))
```

```
## # A tibble: 2 × 5
##   state    year season data.x data.y
##   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; 
## 1 Alabama  2010 Spring x      y     
## 2 Arizona  2010 Spring x      y
```

left_join(): return all rows from x, and all columns from x and y. Rows in x with no match in y will have NA values in the new columns. If there are multiple matches between x and y, all combinations of the matches are returned.


```r
left_join(x, y, by = c("state", "year", "season"))
```

```
## # A tibble: 10 × 5
##    state       year season  data.x data.y
##    &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; 
##  1 Alabama     2010 Spring  x      y     
##  2 Arizona     2010 Spring  x      y     
##  3 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  4 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  5 Arkansas    2010 Spring  x      &lt;NA&gt;  
##  6 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  7 California  2010 Spring  x      &lt;NA&gt;  
##  8 California  2010 Summer  x      &lt;NA&gt;  
##  9 California  2010 Winter  x      &lt;NA&gt;  
## 10 California  2010 Unknown x      &lt;NA&gt;
```
---
right_join(): return all rows from y, and all columns from x and y. Rows in y with no match in x will have NA values in the new columns. If there are multiple matches between x and y, all combinations of the matches are returned.


```r
right_join(x, y, by = c("state", "year", "season"))
```

```
## # A tibble: 10 × 5
##    state    year season  data.x data.y
##    &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; 
##  1 Alabama  2010 Spring  x      y     
##  2 Arizona  2010 Spring  x      y     
##  3 Alabama  2010 Fall    &lt;NA&gt;   y     
##  4 Alabama  2010 Summer  &lt;NA&gt;   y     
##  5 Alabama  2010 Unknown &lt;NA&gt;   y     
##  6 Alabama  2010 Winter  &lt;NA&gt;   y     
##  7 Arizona  2010 Fall    &lt;NA&gt;   y     
##  8 Arizona  2010 Summer  &lt;NA&gt;   y     
##  9 Arizona  2010 Unknown &lt;NA&gt;   y     
## 10 Arizona  2010 Winter  &lt;NA&gt;   y
```

full_join(): return all rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing.


```r
full_join(x, y, by = c("state", "year", "season"))
```

```
## # A tibble: 18 × 5
##    state       year season  data.x data.y
##    &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; 
##  1 Alabama     2010 Spring  x      y     
##  2 Arizona     2010 Spring  x      y     
##  3 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  4 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  5 Arkansas    2010 Spring  x      &lt;NA&gt;  
##  6 Arkansas    2010 Fall    x      &lt;NA&gt;  
##  7 California  2010 Spring  x      &lt;NA&gt;  
##  8 California  2010 Summer  x      &lt;NA&gt;  
##  9 California  2010 Winter  x      &lt;NA&gt;  
## 10 California  2010 Unknown x      &lt;NA&gt;  
## 11 Alabama     2010 Fall    &lt;NA&gt;   y     
## 12 Alabama     2010 Summer  &lt;NA&gt;   y     
## 13 Alabama     2010 Unknown &lt;NA&gt;   y     
## 14 Alabama     2010 Winter  &lt;NA&gt;   y     
## 15 Arizona     2010 Fall    &lt;NA&gt;   y     
## 16 Arizona     2010 Summer  &lt;NA&gt;   y     
## 17 Arizona     2010 Unknown &lt;NA&gt;   y     
## 18 Arizona     2010 Winter  &lt;NA&gt;   y
```
---
So now, let us try and merge together our datasets. 

Let's try an inner join


```r
# Notice that bigfoot has a unit of observation at the sighting level (each
# individual sighting gets a row). I want to change this so that each observation
# is at the state/year/season level to match up with the bigfoot_c_final 
# dataset

bigfoot_summed &lt;- bigfoot %&gt;% 
  group_by(state, season, year) %&gt;% 
  summarize(temperature = mean(temperature, na.rm = TRUE),
            humidity = mean(humidity, na.rm = TRUE),
            visibility = mean(visibility, na.rm = TRUE))

# Let's try combining the two bigfoot datasets
inner_join(bigfoot_summed, bigfoot_c_final, by = c("state", "year", "season"))
```

This worked well. Sometimes, the type of column may not match up. For example, year can sometimes be treated as a character or numeric variable. In this case, you would want to change one of the columns in one of the datasets to match the other.


```r
# Let's save this
bigfoot_final &lt;- inner_join(bigfoot_summed, bigfoot_c_final, by = c("state", "year", "season"))
```
---
## Other ways to combine variables and cases

The `join` functions have some intelligence to their actions. However, you can use a couple of `bind` functions to simply add variables or cases to existing datasets.

Use `bind_cols()` to paste tables beside each other as they are. 
Use `bind_rows()` to paste tables below each other as they are.


```r
a &lt;- bigfoot_final[1:3,]
b &lt;- bigfoot_final[6:8,]
a
```

```
## # A tibble: 3 × 7
## # Groups:   state, season [1]
##   state   season  year temperature humidity visibility sightings
##   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Alabama Fall    1978       NaN     NaN        NaN            1
## 2 Alabama Fall    1979        68.7     0.77       7.83         1
## 3 Alabama Fall    1980       NaN     NaN        NaN            1
```

```r
b
```

```
## # A tibble: 3 × 7
## # Groups:   state, season [1]
##   state   season  year temperature humidity visibility sightings
##   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Alabama Fall    1990       NaN     NaN        NaN            1
## 2 Alabama Fall    1994        76.6     0.79       5.77         1
## 3 Alabama Fall    1999        56.2     0.63       8.28         2
```
---

```r
bind_rows(a, b)
```

```
## # A tibble: 6 × 7
## # Groups:   state, season [1]
##   state   season  year temperature humidity visibility sightings
##   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Alabama Fall    1978       NaN     NaN        NaN            1
## 2 Alabama Fall    1979        68.7     0.77       7.83         1
## 3 Alabama Fall    1980       NaN     NaN        NaN            1
## 4 Alabama Fall    1990       NaN     NaN        NaN            1
## 5 Alabama Fall    1994        76.6     0.79       5.77         1
## 6 Alabama Fall    1999        56.2     0.63       8.28         2
```
---

```r
c &lt;- bigfoot_final[, 1]
d &lt;- bigfoot_final[, 3]
c
```

```
## # A tibble: 2,447 × 1
## # Groups:   state [49]
##    state  
##    &lt;chr&gt;  
##  1 Alabama
##  2 Alabama
##  3 Alabama
##  4 Alabama
##  5 Alabama
##  6 Alabama
##  7 Alabama
##  8 Alabama
##  9 Alabama
## 10 Alabama
## # … with 2,437 more rows
```

```r
d
```

```
## # A tibble: 2,447 × 1
##     year
##    &lt;dbl&gt;
##  1  1978
##  2  1979
##  3  1980
##  4  1981
##  5  1983
##  6  1990
##  7  1994
##  8  1999
##  9  2000
## 10  2001
## # … with 2,437 more rows
```
---

```r
bind_cols(c, d)
```

```
## # A tibble: 2,447 × 2
## # Groups:   state [49]
##    state    year
##    &lt;chr&gt;   &lt;dbl&gt;
##  1 Alabama  1978
##  2 Alabama  1979
##  3 Alabama  1980
##  4 Alabama  1981
##  5 Alabama  1983
##  6 Alabama  1990
##  7 Alabama  1994
##  8 Alabama  1999
##  9 Alabama  2000
## 10 Alabama  2001
## # … with 2,437 more rows
```
---
# Further Cleaning
Let's use some of our skills to get the total number of barrels of beer being produced. 
Here we are going to use a function from the `stringr` package called `str_replace_all`. This is essentially a find and replace for character variables.


```r
## Fixing the names for beer production
names(beer_wide) &lt;- str_replace_all(names(beer_wide),
                                    " ", "")
```
---
I now want to get the total number of barrels of beer produced by combining three different columns. I could do a simple addition here, but I want to show the  `rowSums` function, which will sum up across multiple columns.


```r
beer_wide_final &lt;- beer_wide %&gt;% 
  mutate(barrels = rowSums(across(OnPremises:KegsandBarrels))) %&gt;% 
  select(state, year, barrels) 
```
---
Now we can add Beer Production to our larger bigfoot dataset


```r
beer_wide_final %&gt;% inner_join(bigfoot_final, c("state", "year")) 
```

```
## # A tibble: 0 × 8
## # … with 8 variables: state &lt;chr&gt;, year &lt;dbl&gt;, barrels &lt;dbl&gt;, season &lt;chr&gt;,
## #   temperature &lt;dbl&gt;, humidity &lt;dbl&gt;, visibility &lt;dbl&gt;, sightings &lt;dbl&gt;
```

```r
# Uh oh, notice the difference in the way states are shown. 
# Fortunately, we can use a built in dataset that has the conversion
# of abbreviations to full state names

state_change &lt;- bind_cols(state.abb, state.name) 
names(state_change) &lt;- c("state_abb", "state")

beer &lt;- beer_wide_final %&gt;% 
  inner_join(state_change, by = c("state" = "state_abb")) %&gt;% 
  select(state = state.y, year, barrels)

beerfoot &lt;- beer %&gt;% inner_join(bigfoot_final, c("state", "year")) 
# Much better
```
---
## Visualizing our new dataset

Let's explore our new `beerfoot` dataset.

Are the number of barrels of beer produced and the number of bigfoot sightings
related?


```r
beerfoot %&gt;% 
  ggplot() +
  geom_point(aes(barrels, sightings))
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-30-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;

```r
# Unsure at this point. May need to work through this in 
# another way.
```
---
Before moving forward I want to aggregate our data to be per year. The `summarize` and `mutate` function have a series of helper functions that allow you to make changes to specific variable types or variable groups. Below, we are going to use the `across` function that will allow us to walk across the columns that are numeric and find the mean for each of these columns.


```r
beer_summed &lt;- beerfoot %&gt;% 
  group_by(year) %&gt;% 
  summarize(across(
    .cols = where(is.numeric),
    .fns = list(mean), na.rm = TRUE)
  ) %&gt;% select(-sightings_1)

bf_counts &lt;- beerfoot %&gt;% 
  group_by(year) %&gt;% count() 
```

Here I am renaming a bunch of column names that were renamed above by using the `str_replace` function.


```r
names(beer_summed) &lt;- str_replace(names(beer_summed), "_1", "")

bf &lt;- beer_summed %&gt;% inner_join(bf_counts, by = c("year"))
```
---
Let us try and see if we can better visualize the data we have. 


```r
bf %&gt;% 
  ggplot() +
  geom_point(aes(n, barrels ))
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-33-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;

Seems like a relationship may be here.
---
Let's visually look at this data using a new geom type, `geom_line`. The line graph works well on longitudinal/panel data. 


```r
bf %&gt;% 
  ggplot(aes(year, n)) +
  geom_point() + geom_line() 
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-34-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;
---

```r
# Converting year to factor helps us to discretize the x axis
bf %&gt;% 
  ggplot(aes(as.factor(year), n)) +
  geom_point() + geom_line() 
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-35-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;
---
This works well, but I would like to be able to look across different states and compare. To be able to label each state, I want to use the `ggrepel` package which allows you to label portions of your graph.


```r
#install.packages("ggrepel")
library(ggrepel)

states &lt;- c("Oregon", "Washington", "California")
bigfoot_c_final %&gt;% 
  filter(year &gt; 2000 &amp; states %in% state) %&gt;% 
  group_by(year, state) %&gt;% 
  summarize(sightings = mean(sightings, na.rm = TRUE)) %&gt;% 
  mutate(state_label = if_else(year == 2020, paste0(state), "")) %&gt;%
  ggplot(aes(year, sightings, color= state)) +
  geom_point()  + geom_line() + geom_text_repel(aes(label = state_label)) + theme_classic() + 
  theme(legend.position = "none") 
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-36-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;
---


```r
bf   %&gt;% 
  mutate(barrel_label = paste0(round(barrels, 0), " barrels")) %&gt;% 
  ggplot(aes(year, n, color = barrels)) +
  geom_point() + 
  geom_line() + 
  geom_text_repel(aes(label = barrel_label)) + 
  theme(legend.position = "none")
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-37-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;
---

Finally, I want to show the relationship between beer barrels produced and bigfoot sightings. To do this, I am adding a secondary axis to be able to put both of these variables on the plot at the same time. 


```r
bf  %&gt;% 
  mutate( year = as.factor(year)) %&gt;% 
ggplot(aes(x=year,  group = 1)) +
  geom_line(aes(y=n), color = "blue", linewidth = 1) + 
  geom_line(aes(y=barrels/100000), color = "red", linewidth = 1) +
  scale_y_continuous(
    # Features of the first axis
    name = "Number of Bigfoot Sightings",
    # Add a second axis and specify its features
    sec.axis = sec_axis(~., name="Number of Barrels (*100000)")
  ) + theme_classic() + 
  theme(axis.line.y.right = element_line(color = "red"), 
        axis.ticks.y.right = element_line(color = "red"),
        axis.text.y.right = element_text(color = "red"),
        axis.title.y.right = element_text(color = "red"),
        axis.line.y.left = element_line(color = "blue"), 
        axis.ticks.y.left = element_line(color = "blue"),
        axis.text.y.left = element_text(color = "blue"),
        axis.title.y.left = element_text(color = "blue"))
```

&lt;img src="datawrangling_slides_files/figure-html/unnamed-chunk-38-1.svg" width="50%" height="50%" style="display: block; margin: auto;" /&gt;

So the more beer we make, the fewer bigfoot sightings? Maybe?
---
# Extra Information to help clean data

The final piece I want to look at are similar to the `across` function and they allow you to make changes to many different variables at one time instead of having to make changes to each individual column. The `_at` series of functions allows you to specify the names or location of columns that you want to make changes to. The `_if` series of functions allows you to make changes to columns based off of a specific criteria (numeric, character, etc.). The `_all` series of functions will make changes across all of the variables in your datasets. These functions can be used in conjuction with our earlier dplyr functions like `mutate`, `select`, and `summarize` to make sweeping and efficient changes to your dataset.


```r
vars &lt;- c("barrels", "visibility", "humidity", "temperature")
beerfoot %&gt;% 
  group_by(season) %&gt;% 
  mutate_at(vars, c(mean, sd), na.rm = TRUE) %&gt;% 
  select_if(is.numeric)
```

```
## # A tibble: 641 × 15
## # Groups:   season [5]
##    season  year barrels temper…¹ humid…² visib…³ sight…⁴ barre…⁵ visib…⁶ humid…⁷
##    &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Fall    2008 134207.     45.2   0.56   NaN          1  6.43e6    8.49   0.721
##  2 Spring  2008 134207.     41.1   0.5     10          1  6.15e6    8.42   0.673
##  3 Summer  2009 144304.     54.4   0.73     5.73       1  6.17e6    8.52   0.712
##  4 Fall    2008     NA      67.0   0.805    8.64       2  6.43e6    8.49   0.721
##  5 Spring  2008     NA      41.1   0.745    7.68       2  6.15e6    8.42   0.673
##  6 Winter  2008     NA      41.7   0.76     9.06       2  6.02e6    8.14   0.728
##  7 Winter  2009     NA      47.8   0.51    10          1  6.02e6    8.14   0.728
##  8 Spring  2010     NA      53.6   0.73     8.85       1  6.15e6    8.42   0.673
##  9 Spring  2011   2469.     63.9   0.65     9.5        1  6.15e6    8.42   0.673
## 10 Fall    2012   8986.     51.3   0.51     9.8        1  6.43e6    8.49   0.721
## # … with 631 more rows, 5 more variables: temperature_fn1 &lt;dbl&gt;,
## #   barrels_fn2 &lt;dbl&gt;, visibility_fn2 &lt;dbl&gt;, humidity_fn2 &lt;dbl&gt;,
## #   temperature_fn2 &lt;dbl&gt;, and abbreviated variable names ¹​temperature,
## #   ²​humidity, ³​visibility, ⁴​sightings, ⁵​barrels_fn1, ⁶​visibility_fn1,
## #   ⁷​humidity_fn1
```
---

```r
beerfoot %&gt;% 
  group_by(season) %&gt;% 
  summarize_at(vars, c(mean, sd), na.rm = TRUE) %&gt;% 
  select_if(is.numeric)
```

```
## # A tibble: 5 × 8
##   barrels_fn1 visibility_fn1 humidity_…¹ tempe…² barre…³ visib…⁴ humid…⁵ tempe…⁶
##         &lt;dbl&gt;          &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1    6429266.           8.49       0.721    53.7  7.71e6    2.17  0.138   13.2  
## 2    6152746.           8.42       0.673    57.2  7.65e6    2.35  0.167   12.9  
## 3    6166664.           8.52       0.712    68.1  7.45e6    2.15  0.141   12.5  
## 4   11395121.           6.00       0.815    36.0  1.41e7    2.64  0.0778   0.453
## 5    6019658.           8.14       0.728    41.6  7.60e6    2.44  0.147   14.6  
## # … with abbreviated variable names ¹​humidity_fn1, ²​temperature_fn1,
## #   ³​barrels_fn2, ⁴​visibility_fn2, ⁵​humidity_fn2, ⁶​temperature_fn2
```

```r
my_function &lt;- function(x) { 
  paste0("new ", x)
}

beerfoot %&gt;% 
  mutate_if(is.character, my_function)
```

```
## # A tibble: 641 × 8
##    state        year barrels season     temperature humidity visibility sighti…¹
##    &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;
##  1 new Alaska   2008 134207. new Fall          45.2    0.56      NaN           1
##  2 new Alaska   2008 134207. new Spring        41.1    0.5        10           1
##  3 new Alaska   2009 144304. new Summer        54.4    0.73        5.73        1
##  4 new Alabama  2008     NA  new Fall          67.0    0.805       8.64        2
##  5 new Alabama  2008     NA  new Spring        41.1    0.745       7.68        2
##  6 new Alabama  2008     NA  new Winter        41.7    0.76        9.06        2
##  7 new Alabama  2009     NA  new Winter        47.8    0.51       10           1
##  8 new Alabama  2010     NA  new Spring        53.6    0.73        8.85        1
##  9 new Alabama  2011   2469. new Spring        63.9    0.65        9.5         1
## 10 new Alabama  2012   8986. new Fall          51.3    0.51        9.8         1
## # … with 631 more rows, and abbreviated variable name ¹​sightings
```
---

```r
beerfoot %&gt;% 
  select(6:8) %&gt;% 
  mutate_all(my_function)
```

```
## # A tibble: 641 × 3
##    humidity  visibility sightings
##    &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;    
##  1 new 0.56  new NaN    new 1    
##  2 new 0.5   new 10     new 1    
##  3 new 0.73  new 5.73   new 1    
##  4 new 0.805 new 8.645  new 2    
##  5 new 0.745 new 7.68   new 2    
##  6 new 0.76  new 9.06   new 2    
##  7 new 0.51  new 10     new 1    
##  8 new 0.73  new 8.85   new 1    
##  9 new 0.65  new 9.5    new 1    
## 10 new 0.51  new 9.8    new 1    
## # … with 631 more rows
```

```r
replace_function &lt;- function(x) {
  ifelse(is.na(x), -1, x)
}

beerfoot %&gt;% 
  select(3:8) %&gt;% 
  mutate_all(replace_function)
```

```
## # A tibble: 641 × 6
##    barrels season temperature humidity visibility sightings
##      &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
##  1 134207. Fall          45.2    0.56       -1            1
##  2 134207. Spring        41.1    0.5        10            1
##  3 144304. Summer        54.4    0.73        5.73         1
##  4     -1  Fall          67.0    0.805       8.64         2
##  5     -1  Spring        41.1    0.745       7.68         2
##  6     -1  Winter        41.7    0.76        9.06         2
##  7     -1  Winter        47.8    0.51       10            1
##  8     -1  Spring        53.6    0.73        8.85         1
##  9   2469. Spring        63.9    0.65        9.5          1
## 10   8986. Fall          51.3    0.51        9.8          1
## # … with 631 more rows
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "3:2",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
